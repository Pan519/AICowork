# AICowork 功能专题教程

> **深度讲解核心功能的使用技巧和最佳实践**

---

## 📑 专题列表

1. [记忆系统完全指南](#专题一记忆系统完全指南)
2. [技能开发实战](#专题二技能开发实战)
3. [API 配置与管理](#专题三-api-配置与管理)
4. [工作目录与会话管理](#专题四工作目录与会话管理)
5. [提示词工程技巧](#专题五提示词工程技巧)
6. [权限管理与安全](#专题六权限管理与安全)
7. [插件与扩展开发](#专题七插件与扩展开发)
8. [性能优化指南](#专题八性能优化指南)

---

## 专题一：记忆系统完全指南

### 1.1 记忆系统核心概念

#### 什么是记忆系统？

记忆系统是一个**本地化的智能知识库**，具有三大核心能力：

```
┌─────────────────────────────────────┐
│        记忆系统核心能力              │
├─────────────────────────────────────┤
│ 1. 持久化存储                        │
│    - 本地存储，不上传云端            │
│    - 支持大量文本数据                │
│    - 快速读写                        │
├─────────────────────────────────────┤
│ 2. 智能搜索                          │
│    - 词法搜索（BM25）                │
│    - 语义搜索（向量）                │
│    - 自动混合模式                    │
├─────────────────────────────────────┤
│ 3. RAG 问答                          │
│    - 检索增强生成                    │
│    - 基于上下文回答                  │
│    - 引用来源                        │
└─────────────────────────────────────┘
```

#### 为什么使用记忆系统？

**场景 1：项目信息管理**

```
❌ 不使用记忆系统：
- 每次对话都要重新说明项目结构
- 容易遗忘重要的配置信息
- 难以维护项目知识

✅ 使用记忆系统：
- 保存项目配置、目录结构
- 随时快速检索
- AI 自动应用项目上下文
```

**场景 2：个人知识库**

```
保存内容：
- 学习笔记
- 技术要点
- 代码片段
- 问题解决方案

使用场景：
- 快速查找历史笔记
- 让 AI 基于已有知识回答
- 构建个人知识体系
```

### 1.2 记忆分类最佳实践

#### 分类策略

```
📁 项目相关（project）
  ├─ 项目结构
  ├─ 配置文件路径
  ├─ 依赖关系
  └─ 部署信息

⚙️ 用户偏好（preference）
  ├─ 编码风格
  ├─ 常用参数
  ├─ 工具偏好
  └─ 操作习惯

💡 技术记录（technical）
  ├─ 设计模式
  ├─ 算法实现
  ├─ 调试技巧
  └─ 最佳实践

📝 上下文信息（context）
  ├─ 项目背景
  ├─ 业务逻辑
  ├─ 需求文档
  └─ 约束条件

💬 对话摘要（conversation）
  ├─ 重要决策
  ├─ 讨论结论
  ├─ 问题方案
  └─ 思考过程

🏷️ 自定义（custom）
  └─ 按需创建
```

#### 分类选择决策树

```
开始
  │
  ├─ 是否与当前项目相关？
  │   ├─ 是 → 📁 项目相关
  │   └─ 否 → 继续
  │
  ├─ 是否是个人习惯或偏好？
  │   ├─ 是 → ⚙️ 用户偏好
  │   └─ 否 → 继续
  │
  ├─ 是否是技术知识或代码？
  │   ├─ 是 → 💡 技术记录
  │   └─ 否 → 继续
  │
  ├─ 是否是背景或上下文？
  │   ├─ 是 → 📝 上下文信息
  │   └─ 否 → 继续
  │
  ├─ 是否是对话总结？
  │   ├─ 是 → 💬 对话摘要
  │   └─ 否 → 🏷️ 自定义
```

### 1.3 标签系统设计

#### 标签命名规范

```
✅ 好的标签：
- "React"（清晰）
- "前端开发"（明确）
- "重要配置"（描述性）

❌ 不好的标签：
- "a"（太短）
- "东西"（模糊）
- "12345"（无意义）
```

#### 标签层级设计

```
一级标签（类别）：
- 前端、后端、数据库、运维

二级标签（技术）：
- React、Vue、Python、MySQL

三级标签（具体）：
- Hooks、状态管理、API设计
```

#### 推荐标签集合

```
按技术栈：
├─ 编程语言：JavaScript、Python、Java、Go
├─ 框架：React、Vue、Spring、Django
├─ 数据库：MySQL、MongoDB、Redis
└─ 工具：Git、Docker、Kubernetes

按用途：
├─ 学习：笔记、教程、文档
├─ 工作：项目、会议、任务
└─ 个人：想法、计划、总结

按优先级：
├─ 重要：紧急、核心、关键
└─ 普通：参考、备用、归档
```

### 1.4 搜索技巧

#### 词法搜索技巧

```
技巧1：使用关键词
  搜索："React Hooks"
  而非："React 和 Hooks 的使用"

技巧2：使用专业术语
  搜索："RESTful API"
  而非："网页接口"

技巧3：使用英文术语
  搜索："TypeScript generic"
  而非："泛型"
```

#### 语义搜索技巧

```
技巧1：描述性搜索
  搜索："如何处理异步错误"
  不需要精确的关键词

技巧2：概念性搜索
  搜索："状态管理方案"
  而非具体的状态库名称

技巧3：场景化搜索
  搜索："处理大文件上传"
  AI 能理解你的意图
```

#### 搜索策略选择

```
场景1：已知关键词
  → 使用词法搜索
  示例：搜索已知的函数名、文件名

场景2：概念模糊
  → 使用语义搜索
  示例：描述问题的现象而非原因

场景3：不确定
  → 使用自动混合
  让系统自动选择最佳方式
```

### 1.5 RAG 问答技巧

#### 提问技巧

```
❌ 差的提问：
"怎么配置？"
（缺少上下文）

✅ 好的提问：
"如何配置 React 的开发环境？"
（明确具体场景）
```

#### 多轮对话

```
第一轮：
用户：项目的数据库配置在哪里？
AI：[搜索记忆] 在 config/db.json 文件中

第二轮：
用户：那生产环境的配置呢？
AI：[继续搜索] 生产环境配置在 config/db.prod.json
```

#### 获取来源

```
利用 AI 的引用功能：
- 查看信息来源
- 验证准确性
- 深入了解详情
```

### 1.6 记忆维护

#### 定期清理

```
建议：
1. 每月检查一次记忆列表
2. 删除过时或重复的内容
3. 合并相似的记忆
4. 更新有变化的信息
```

#### 数据备份

```
自动备份：
1. 设置 → 记忆系统
2. 定期导出所有记忆
3. 保存到多个位置

手动备份：
1. 进入多选模式
2. 全选记忆
3. 导出为 JSON
4. 保存到云盘或外部存储
```

#### 数据迁移

```
场景：更换电脑

步骤：
1. 旧电脑：导出所有记忆
2. 将 JSON 文件传输到新电脑
3. 新电脑：导入记忆文件
4. 验证数据完整性
```

### 1.7 高级技巧

#### 记忆模板

```
创建结构化的记忆模板：

标题格式：[类别] [项目] [具体内容]

示例：
[项目] MyApp 数据库配置
[技术] React Hooks 使用规范
[偏好] 代码风格配置
```

#### 批量操作

```
场景：整理项目相关的记忆

步骤：
1. 搜索项目名称
2. 进入多选模式
3. 全选结果
4. 统一添加项目标签
5. 或统一导出备份
```

#### 记忆链接

```
技巧：在记忆中引用其他记忆

示例：
记忆A：项目根目录
记忆B：在内容中引用："参见 [项目根目录]"

这样相关信息可以相互关联
```

---

## 专题二：技能开发实战

### 2.1 技能开发基础

#### 什么是技能？

```
技能 = 预定义的提示词模板 + 参数化能力

核心价值：
1. 复用性：一次创建，多次使用
2. 标准化：统一输出格式
3. 效率：避免重复输入
4. 共享：可以分享给他人
```

#### 技能的组成

```
技能结构：
├─ 基本信息
│  ├─ 技能名称：唯一标识
│  ├─ 技能描述：功能说明
│  └─ 标签：分类标记
│
├─ 提示词模板
│  └─ 使用 {参数} 占位符
│
└─ 参数定义
   ├─ 参数名称
   ├─ 参数类型
   └─ 默认值
```

### 2.2 创建第一个技能

#### 实战：代码审查技能

```
步骤1：规划技能
  名称：code-review
  功能：审查代码并给出建议
  参数：{code} - 要审查的代码

步骤2：编写提示词模板

你是一位经验丰富的代码审查员。请审查以下代码：

```
{code}
```

审查要点：
1. 代码风格和可读性
2. 潜在的 bug 和错误
3. 性能问题
4. 安全隐患
5. 最佳实践建议

请以 Markdown 格式输出审查结果。

步骤3：创建技能
1. 设置 → 技能管理
2. 点击"+ 新建技能"
3. 填写信息并保存

步骤4：测试技能
输入：/code-review function test() { return 1; }
查看 AI 的审查结果
```

### 2.3 高级技能开发

#### 多参数技能

```
技能：git-commit

提示词模板：
请为以下代码变更生成符合规范的 Git 提交消息：

变更类型：{type}
变更范围：{scope}
变更描述：
{diff}

要求：
- 使用 Conventional Commits 格式
- 简洁明了的标题（50字以内）
- 必要时添加详细说明

参数定义：
- type: feat/fix/docs/style/refactor/test/chore
- scope: 变更范围（如：auth, ui, api）
- diff: 代码差异内容
```

#### 条件逻辑

```
技巧：在提示词中实现条件逻辑

模板：
{{#if detailed}}
详细模式：请提供完整的分析报告
{{else}}
简洁模式：只列出关键问题
{{/if}}

实现：使用不同的参数值控制行为
```

#### 链式技能

```
技能A：生成代码框架
技能B：审查代码
技能C：优化代码

使用流程：
1. /generate-framework React
2. /review-code [使用步骤1的输出]
3. /optimize-code [使用步骤2的结果]
```

### 2.4 技能库推荐

#### 代码相关

```
1. 代码生成器
   功能：根据描述生成代码
   参数：{language} {description}

2. 代码解释器
   功能：解释代码的功能
   参数：{code}

3. 代码转换器
   功能：代码语言转换
   参数：{from} {to} {code}

4. 单元测试生成器
   功能：生成单元测试
   参数：{code} {framework}
```

#### 文档相关

```
1. 文档生成器
   功能：从代码生成文档
   参数：{code}

2. README 生成器
   功能：生成项目 README
   参数：{project_name} {features}

3. API 文档生成器
   功能：生成 API 文档
   参数：{endpoints}
```

#### 数据处理

```
1. JSON 格式化器
   功能：格式化 JSON 数据
   参数：{json}

2. 数据转换器
   功能：转换数据格式
   参数：{from} {to} {data}

3. 数据验证器
   功能：验证数据格式
   参数：{schema} {data}
```

### 2.5 技能调试技巧

#### 逐步测试

```
1. 先用简单参数测试
2. 逐步增加复杂度
3. 记录每次结果
4. 找出问题所在
```

#### 日志记录

```
在技能中添加调试输出：

<!-- DEBUG: 输入参数 -->
参数值：{param}

<!-- DEBUG: 处理结果 -->
中间结果：...
```

#### 版本管理

```
为技能添加版本信息：

名称：skill-name-v1
名称：skill-name-v2

这样可以保留旧版本，方便对比和回退
```

### 2.6 技能分享

#### 导出技能

```
1. 设置 → 技能管理
2. 选择要分享的技能
3. 点击"导出"
4. 保存为 JSON 文件
```

#### 技能文档

```
为技能创建使用文档：

技能名称：XXX
功能：XXX
参数：
  - param1: 说明
  - param2: 说明
示例：/skill-name param1=value1 param2=value2
注意事项：XXX
```

---

## 专题三：API 配置与管理

### 3.1 API 基础知识

#### Claude API 限制

```
免费账户：
- 每分钟请求次数：5
- 每日 Token 限制：较低

付费账户：
- 每分钟请求次数：50+
- 每日 Token 限制：较高

建议：
- 开发阶段使用 Haiku 模型（经济）
- 生产环境使用 Sonnet 模型（平衡）
- 复杂任务使用 Opus 模型（最强）
```

#### 模型选择指南

```
Claude Haiku（最快）
适用场景：
- 简单问答
- 快速原型
- 批量处理
成本：最低

Claude Sonnet（推荐）
适用场景：
- 日常开发
- 文档写作
- 代码审查
成本：中等

Claude Opus（最强）
适用场景：
- 复杂推理
- 创意写作
- 深度分析
成本：最高
```

### 3.2 多配置策略

#### 场景化配置

```
配置1：开发环境
模型：Claude Haiku
Temperature：0.3（稳定）
Max Tokens：4096
用途：日常开发调试

配置2：文档写作
模型：Claude Sonnet
Temperature：0.8（创意）
Max Tokens：8192
用途：技术文档撰写

配置3：代码审查
模型：Claude Opus
Temperature：0.1（精确）
Max Tokens：4096
用途：重要代码审查
```

#### 成本优化

```
策略1：分级使用
- 简单任务 → Haiku
- 一般任务 → Sonnet
- 复杂任务 → Opus

策略2：Token 限制
- 设置合理的 Max Tokens
- 避免不必要的长输出

策略3：缓存利用
- 相似问题复用答案
- 使用记忆系统减少重复
```

### 3.3 高级参数调优

#### Temperature

```
0.0 - 0.3：精确模式
- 代码生成
- 数据转换
- 需要确定性的任务

0.4 - 0.7：平衡模式
- 日常对话
- 文档写作
- 代码解释

0.8 - 1.0：创意模式
- 创意写作
- 头脑风暴
- 内容生成

1.1 - 2.0：随机模式
- 实验性任务
- 探索可能性
```

#### Top P

```
作用：控制输出的多样性

推荐值：
- 0.1：高度集中（技术文档）
- 0.5：平衡（一般对话）
- 0.9：多样（创意写作）

通常与 Temperature 配合使用
```

#### Max Tokens

```
设置建议：

短回复（512-1024）：
- 简单问答
- 代码片段
- 摘要生成

中等回复（2048-4096）：
- 代码解释
- 文档说明
- 问题分析

长回复（8192+）：
- 完整教程
- 深度分析
- 创意写作
```

### 3.4 兼容服务配置

#### 自建代理

```
场景：使用自建的 Claude API 代理

配置：
Base URL: http://your-proxy.com/v1
API Key: your-custom-key
模型名称：保持原模型名

注意：确保代理兼容 Claude API 格式
```

#### Azure OpenAI

```
配置步骤：
1. 选择 API 类型：Azure
2. 填写资源名称
3. 填写部署名称
4. 填写 API Key
5. Base URL 自动生成

Azure 特有字段：
- 资源名称：your-resource-name
- 部署名称：your-deployment-name
```

### 3.5 API 安全

#### Key 管理

```
最佳实践：
1. 不要分享 API Key
2. 定期轮换 API Key
3. 为不同环境使用不同 Key
4. 监控 API 使用量
5. 设置预算告警
```

#### 访问控制

```
团队使用：
- 为每个成员分配独立 Key
- 设置使用额度限制
- 定期审查使用记录
```

---

## 专题四：工作目录与会话管理

### 4.1 工作目录的作用

#### 为什么需要工作目录？

```
场景1：项目开发
设置工作目录：/path/to/project
AI 可以：
- 读取项目文件
- 理解项目结构
- 提供上下文相关的建议

场景2：文档处理
设置工作目录：/path/to/docs
AI 可以：
- 读取文档内容
- 跨文件引用
- 批量处理
```

#### 权限管理

```
AI 对工作目录的权限：
- 读取文件
- 列出目录
- 搜索内容
- 分析文件

无法执行：
- 修改文件（除非明确授权）
- 删除文件
- 执行程序
```

### 4.2 会话管理策略

#### 按项目创建会话

```
项目A：
├─ 会话1：功能开发
├─ 会话2：Bug 修复
└─ 会话3：代码审查

项目B：
├─ 会话1：架构设计
└─ 会话2：性能优化

好处：
- 上下文清晰
- 历史可追溯
- 方便切换
```

#### 按任务类型创建会话

```
代码开发会话：
- 设置项目目录
- 启用代码审查技能
- 使用技术型模型

文档写作会话：
- 设置文档目录
- 启用写作技能
- 使用创意型模型

学习研究会话：
- 启用记忆系统
- 启用自动保存
- 使用强推理模型
```

### 4.3 会话最佳实践

#### 命名规范

```
好的会话名：
- "项目A - 用户认证开发"
- "Bug修复 - 登录失败"
- "代码审查 - PR#123"

避免：
- "新对话 1"
- "对话 2"
- "测试"
```

#### 会话生命周期

```
创建：
- 明确目标
- 设置工作目录
- 选择合适的配置

使用：
- 保持专注
- 定期总结
- 保存重要信息

结束：
- 清理无用内容
- 保存到记忆
- 归档或删除
```

---

## 专题五：提示词工程技巧

### 5.1 提示词基础

#### CLEAR 原则

```
C - Concise（简洁）
    直接说明需求，避免冗余

L - Logical（逻辑）
    按照逻辑顺序组织内容

E - Explicit（明确）
    清晰表达，避免歧义

A - Action-oriented（行动导向）
    明确期望 AI 做什么

R - Relevant（相关）
    只提供必要的信息
```

### 5.2 高级技巧

#### 角色设定

```
❌ 平淡：
"帮我写代码"

✅ 角色：
"你是一位拥有10年经验的高级软件工程师，
精通 React 和 TypeScript。请帮我..."

效果：
- AI 会以专家视角回答
- 输出更专业
- 建议更实用
```

#### 示例驱动

```
技巧：提供示例提高准确度

请按以下格式输出：

示例：
```
输入：示例输入
输出：期望的输出格式
```

现在处理这个：
输入：{user_input}
```

#### 分步推理

```
Chain of Thought 提示：

请逐步思考并回答：

1. 首先分析问题
2. 然后考虑可能的方案
3. 评估每种方案的优缺点
4. 最后给出最佳方案和理由

问题：{question}
```

### 5.3 场景化提示词

#### 代码生成

```
请生成以下功能的代码：

语言：{language}
框架：{framework}
功能描述：{description}

要求：
1. 遵循最佳实践
2. 包含错误处理
3. 添加必要的注释
4. 考虑性能优化

请先给出实现思路，再编写代码。
```

#### 文档撰写

```
请撰写以下文档：

类型：{api_docs|user_guide|tutorial}
主题：{topic}
受众：{audience}

要求：
1. 结构清晰，层次分明
2. 语言简洁易懂
3. 包含示例代码
4. 添加必要的注意事项

请先列出大纲，再逐步展开。
```

#### 问题调试

```
我遇到了以下问题：

代码：
```
{code}
```

错误信息：
```
{error}
```

环境：
- 语言：{language}
- 版本：{version}
- 平台：{platform}

请：
1. 分析可能的原因
2. 提供调试步骤
3. 给出解决方案
```

---

## 专题六：权限管理与安全

### 6.1 权限体系

#### 权限类型

```
文件操作权限：
├─ 读取文件
├─ 写入文件
├─ 创建目录
└─ 删除文件

网络权限：
├─ HTTP 请求
├─ WebSocket 连接
└─ API 调用

系统权限：
├─ 执行命令
├─ 读取环境变量
└─ 访问系统信息
```

#### 权限级别

```
级别1：完全开放
- 所有操作自动允许
- 适合可信环境
- 风险最高

级别2：按次确认
- 每次操作都询问
- 安全性高
- 可能影响体验

级别3：白名单
- 只允许特定操作
- 安全可控
- 需要配置

推荐：级别2（按次确认）
```

### 6.2 安全最佳实践

#### API Key 保护

```
✅ 安全做法：
- 使用环境变量
- 定期轮换 Key
- 限制 Key 权限
- 监控使用情况

❌ 危险做法：
- 硬编码在代码中
- 提交到版本控制
- 在公开场合分享
- 使用无限制的 Key
```

#### 数据隐私

```
敏感信息处理：
1. 不要在对话中包含密码
2. 使用占位符代替真实数据
3. 定期清理敏感记忆
4. 加密存储重要配置

示例：
❌ "我的密码是 123456"
✅ "我的密码是 [PASSWORD]"
```

---

## 专题七：插件与扩展开发

### 7.1 插件架构

#### 插件类型

```
UI 插件：
- 自定义界面元素
- 添加新面板
- 修改显示样式

功能插件：
- 添加新功能
- 集成第三方服务
- 扩展 AI 能力

数据插件：
- 新的数据源
- 自定义存储
- 数据转换
```

### 7.2 MCP 服务器开发

#### MCP 协议基础

```
MCP 服务器结构：
{
  "name": "server-name",
  "version": "1.0.0",
  "tools": [
    {
      "name": "tool-name",
      "description": "工具描述",
      "parameters": {...}
    }
  ]
}
```

#### 创建 MCP 工具

```
示例：天气查询工具

{
  "name": "get-weather",
  "description": "查询指定城市的天气",
  "parameters": {
    "city": {
      "type": "string",
      "description": "城市名称",
      "required": true
    }
  },
  "handler": async (params) => {
    // 调用天气 API
    const weather = await fetchWeather(params.city);
    return weather;
  }
}
```

---

## 专题八：性能优化指南

### 8.1 应用性能优化

#### 启动速度

```
优化措施：
1. 减少自动加载的记忆数量
2. 禁用不必要的插件
3. 清理历史对话
4. 定期清理缓存
```

#### 运行内存

```
内存占用优化：
1. 限制对话历史长度
2. 定期重启应用
3. 关闭不需要的会话
4. 清理无用记忆
```

### 8.2 API 调用优化

#### 减少Token消耗

```
技巧1：精简输入
❌："能否请你帮我检查一下这段代码有什么问题..."
✅："检查代码问题："

技巧2：使用记忆
保存常用信息到记忆
避免每次重复说明

技巧3：分批处理
大任务拆分成小任务
逐步处理
```

#### 提高响应速度

```
优化策略：
1. 使用更快的模型（Haiku）
2. 减少上下文长度
3. 简化提示词
4. 并行处理独立任务
```

### 8.3 记忆系统优化

#### 搜索性能

```
优化技巧：
1. 使用词法搜索（更快）
2. 限制搜索结果数量
3. 使用精确关键词
4. 合理使用标签
```

#### 存储优化

```
定期维护：
1. 删除过时记忆
2. 合并重复内容
3. 压缩大段文本
4. 使用分类和标签
```

---

## 附录：快捷技巧速查

### 常用操作快捷键

```
Ctrl + N     新建对话
Ctrl + /     斜杠命令
Ctrl + ,     打开设置
Enter         发送消息
Shift + Enter 换行
Escape        关闭弹窗
```

### 斜杠命令速查

```
/help              显示帮助
/clear             清空对话
/memory save       保存到记忆
/memory search     搜索记忆
/memory ask        记忆问答
```

### 常见问题快速解决

```
问题：API调用失败
解决：检查网络 → 检查API Key → 测试连接

问题：搜索无结果
解决：检查记忆内容 → 更换关键词 → 切换搜索模式

问题：应用卡顿
解决：重启应用 → 清理缓存 → 减少历史记录
```

---

**文档版本**: 1.1.0
**最后更新**: 2026-01-22
**适用版本**: AICowork 0.1.0+
